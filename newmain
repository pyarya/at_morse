/*
 * File:   newavr-main.c
 * Author: main
 *
 * Created on November 30, 2024, 2:35 PM
 */

#define F_CPU 14745600UL

#include "defines.h"

#include <ctype.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include <avr/io.h>
#include <avr/pgmspace.h>

#include <util/delay.h>

#include "lcd.h"

FILE lcd_str = FDEV_SETUP_STREAM ( lcd_putchar , NULL , _FDEV_SETUP_WRITE ) ; 

ISR ( TIMER0_OVF_vect ){

    overflow++;

}

void init() {
    DDRB &= ~( 1 << PD3 ); //Enable as input (Mode select button)
    PORTB |= (1 << PD3 ); //Enable pull up resistor
}
volatile uint16_t overflow = 0;
        
int main ( void ) {
    init();
    
    char buffer[];
    
    uint8_t state = 0; //TX mode = 0x00, RX mode = 0xFF, TX default state
    
    while ( 1 ) {
    
        if ( ~( PIND & ( 1 << PD3 ) ) ) { //If the button is pressed
        
            state = ~state;
        
        }
        
        if ( state = 0 ) {
            
            fprintf (&lcd_str, "\x1b\x01" ); //Clears the display
            fprintf (&lcd_str, "Transmitting"); //Prints input
        
            while ( ( PIND & ( 1 << PD5 ) ) );
            char transmit;
            
            fprintf (&lcd_str, "\x1b\xc0%c", buffer); //Prints input
        
        }
        else {
            
            fprintf (&lcd_str, "\x1b\x01" ); //Clears the display
            fprintf (&lcd_str, "Receiving"); //Prints input
        
            char recieve;
            
            fprintf (&lcd_str, "\x1b\xc0%c", buffer); //Prints input
        
        }
           
    }
    
}

char transmit () {
    
    int t0, t1, time, i;
    char buffer[];
    
    i = 0;
    
    if ( ~( PIND & ( 1 << PD5 ) ) ) {
    
        t0 = TCNT0;
    
    }
    
    while ( ~( PIND & ( 1 << PD5 ) ) );
    
    t1 = TCNT0;
    
    time = ( t1 - t0 + ( overflow * 65536 ) ) / F_CPU;
    
    if ( overflow = 1 ){
    
        overflow = 0;
    
    }
    
    if ( 0.2 < time <= 1.5 ) {
    
        buffer[i] = '.';
    
    }
    else if ( 1.5 < time < 3.5 ) {
    
        buffer[i] = '_';
    
    }
    
    i++;
    
}

char recieve () {

    

}



// Morse Code Lookup Table
const char *morse_table[36] = {
    ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", // A-J
    "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", // K-T
    "..-", "...-", ".--", "-..-", "-.--", "--..",                       // U-Z
    "-----", ".----", "..---", "...--", "....-", ".....", "-....", "--...", // 0-7
    "---..", "----."                                                // 8-9
};
const char ascii_table[36] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";


int DOTMIN = 400;
int DOTMAX = 600;
int DASHMIN = 1400;
int DASHMAX = 1600;
int LETTERMIN = 1400;
int LETTERMAX = 1600;
int SPACEMIN = 3400;
int SPACEMAX = 3600;

int morseCounter = 0;
char morse[8];

void bintoascii(int onLast, int on, int offLast, int off)// this needs to change depending on how the timer variables are implemented
{
    if ((off & on)==0){// this condition is to check if the signal changes from on to off. If that is true, then proceed with translation
        //realistically this can be changed if this translate is only set to trigger every time the signal changes
        if (DOTMIN <= onLast && onLast <= DOTMAX) // window for placing a dot into the morse buffer
        {
            morse[morsecCounter] = ".";
            morseCounter++1;
        }
        if (DASHMIN <= onLast && onLast <= DASHMAX)// window for placing a dash into the morse buffer
        {
            morse[morsecCounter] = "-";
            morseCounter++1;
        }
        
        if (LETTERMIN <= offLast && offLast <= LETTERMAX) // signal is off long enough to translate the morse buffer into a letter, then clear the morse buffer
        {
           // Compare the target string with each string in the list
            int found = 0;  // Flag to indicate if the string was found
            morse[morseCounter] = '\0'; // Null-terminate the Morse code
            for (int i = 0; i < 36; i++) {
                if (strcmp(list[i], target) == 0) {  // strcmp returns 0 if strings are equal
                    found = 1;
                    fprintf(&lcd_str, "%s", ascii_table[i]);
                    break;
                }

                if (!found) {
                    fprintf(&lcd_str, "?");
                }
        
            morse[0] = '\0';
            morsecounter = 0;
        }   
                    
        if (SPACEMIN <= offLast && offLast <= SPACEMAX) //  signal is off long enough to place a space character, clearing morse buffer
        {
            morse[0] = '\0';
            morsecounter = 0;
            fprintf(&lcd_str, " ");
        }
        
     
    }
  
}
